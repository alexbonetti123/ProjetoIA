<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body >
    <div id="root">
        <table id="tabela">

        </table>
    </div>
</body>
<script>
    class Agente {
    constructor(posX, posY, labirinto) {
        this.posX = posX
        this.posY = posY
        this.labirinto = labirinto
    }
    getPosX() {
        return this.posX
        
    }
    getPosY() {
        return this.posY
    }
    proxSujo() {
        let res = this.labirinto.getProxSujo()
        return res
    }
    async moverAgente() {
        let retorno = await this.labirinto.movimentar({x:this.posX, y:this.posY})
        if(retorno !== undefined) {
            console.log("Retorno: " + retorno.x + ", " + retorno.y)
            this.posX = retorno.x
            this.posY = retorno.y
        }
    }
    async inicarLimpeza() {
        this.labirinto.ordenarLista()
       for(let i = 0; i < this.labirinto.getTamanhoLista(); i++){
           this.moverAgente()
           await this.sleep(2000)
       }
       this.escreverLabirinto()
       await this.sleep(5000)
       console.log("Minha eficiência foi de: " + this.verificarPorcetangemEficiencia() + "%")
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    verificarPorcetangemEficiencia() {
        let pct = 100 * (this.labirinto.getLimpos() / (this.labirinto.linhas * this.labirinto.colunas))
        return pct.toFixed(2)
    }
    escreverLabirinto() {
        this.labirinto.escreverLabirinto()
    }
    
}
class Labirinto {
    constructor(linhas, colunas) {
        this.linhas = linhas
        this.colunas = colunas
        this.matriz = [[],[],[]]
        this.listaPosicoes = []
        this.reintegrados = []
        this.sujos = 0
        this.limpos = 0
        this.contador = 0
    }
    getTamanhoLista() {
        return this.listaPosicoes.length
    }
    getLimpos() {
        return this.limpos
    }
    getSujos() {
        return this.sujos
    }
    iniciarLabirinto(x, y) {
        this.matriz[x][y] = 'A'
        for(let i = 0; i < this.linhas; i++){
            for(let j = 0; j < this.colunas; j++){
                let valor = Math.round(Math.random())
                if(valor === 1 && this.matriz[i][j] != 'A'){
                    this.matriz[i][j] = 'L'
                }
                if(valor === 0 && this.matriz[i][j] != 'A'){
                    this.criarLista(i, j, 'S')
                    this.matriz[i][j] = 'S'
                    this.sujos = this.sujos + 1
                }
            }
        }
    }
    ordenarLista() {
        this.listaPosicoes.sort((a, b) => {
            if(a.soma < b.soma)
                return 1
            if(a.soma > b.soma)
                return -1
            if(a.soma == b.soma)
                return 0
        })
    }
    getProxSujo() {
        let elemento = this.listaPosicoes.pop()
        return elemento
        
    }
    criarLista(x, y, status) {
        this.listaPosicoes.push({
            linha:x,
            coluna:y,
            status:status,
            soma:x + y
        })
    }
    async movimentar(agPosAtual) {
        this.escreverLabirinto()
        let {x, y} = agPosAtual
        let limpou = false
        let elemento = this.getProxSujo()
        //Testando se posso mover para cima ou para baixo
        console.log(elemento)
        if(elemento.status === 'S'){
            if((elemento.linha - x === 1 || elemento.linha - x === -1) && limpou === false){
                this.matriz[x][y] = 'L'
                this.matriz[elemento.linha][elemento.coluna] = 'A'
                limpou = true
                this.limpos++
                //Retorna a nova posição do agente
                return {x:elemento.linha, y:elemento.coluna}
            }
            //Testando se pode se mover para os lados, ou seja, mover em Y(coluna)
            if((elemento.coluna - y === 1 || elemento.coluna - y === -1) && limpou === false){
                this.matriz[x][y] = 'L'
                this.matriz[elemento.linha][elemento.coluna] = 'A'
                limpou = true
                this.limpos++
                //Retorna a nova posição do agente
                return {x:elemento.linha, y:elemento.coluna}
            }
            if((elemento.linha - x === 1 || elemento.linha - x === -1) && (elemento.coluna - y === 1 || elemento.coluna - y === -1) && limpou === false){
                this.matriz[x][y] = 'L'
                this.matriz[elemento.linha][elemento.coluna] = 'A'
                limpou = true
                this.limpos++
                //Retorna a nova posição do agente
                return {x:elemento.linha, y:elemento.coluna}
            }
            
            if(limpou === false){ 
                return {x, y}
            }    
        }
        
    }
    /*verificarReintegracao(x, y) {
        let elemento = this.reintegrados.findIndex(elen => elen.linha === x && elen.coluna === y)
        console.log("Ja vou reintegrado? " + elemento)
        return elemento
    }*/
    /*if(this.verificarReintegracao() == -1){
        console.log("Integrou")
        //Nao reintegrou
        this.listaPosicoes.push({
            linha:elemento.linha,
            coluna:elemento.coluna, 
            status:'S'
        }) 
        this.reintegrados.push({
            linha:elemento.linha,
            coluna:elemento.coluna
        })
    }*/
    escreverLabirinto(){
        this.matriz.map(valor => {
            let tr = document.createElement("tr")
            valor.forEach(i => {
                let td = document.createElement("td")
                td.innerText = i
                tr.appendChild(td)
                document.getElementById("tabela").appendChild(tr)
            })
            
            
        })
        let espaco = document.createElement("h1")
            espaco.innerHTML = ""
            document.getElementById("tabela").appendChild(espaco)
           
    }
}
let lab = new Labirinto(3, 3);
let ag = new Agente(0, 0, lab)
lab.iniciarLabirinto(ag.getPosX(), ag.getPosY())
ag.inicarLimpeza()
</script>
</html>